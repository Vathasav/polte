---
# workarounds for both api nodes
- hosts: api
  become: true
  become_user: root
  pre_tasks:
# workaround: selinux blocks rabbitmq HiPE compilation
# Obviously this is rather evil as workarounds go. Up to the reader's
# consideration to either uncomment or (preferably) replace with a proper fix.
#    - shell: sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config
#    - shell: sleep 5 && shutdown -r now
#      async: 1
#      poll: 0
#      args:
#        creates: /usr/bin/pip-python
#      ignore_errors: true
#    - meta: clear_host_errors
#    - pause:
#        seconds: 40
# workaround: pip provider fails
    - shell: ln -s /usr/bin/pip /usr/bin/pip-python
      args:
        creates: /usr/bin/pip-python
# workaround: create NFS share for glance
    - file:
        path: /mnt/glance_nfs/cloud_devel
        state: directory
        recurse: yes
        mode: 0755
#    - meta: clear_host_errors
  roles:
    - { role: ansible-role-nfs, nfs_exports: { "/mnt/glance_nfs/cloud_devel *(rw,sync,no_root_squash)" } }

# First we run Puppet on the "primary" API node. This is a necessary step as
# opposed to just running it on all at the same time, since setting up DRBD and
# Pacemaker must be done this way.
- hosts: api[0]
  become: true
  become_user: root
  roles:
    - { role: ansible-role-puppetize, ansible_fqdn: "{{inventory_hostname_short}}.openstacklocal", ignore_puppetize_errors: true }
# workaround: flush iptables momentarily
  post_tasks:
    - shell: iptables -F

# Then we run Puppet on the rest of the API nodes.
#- hosts: api:!api[0]
# workaround: run for api-node0 too, to expedite initial provisioning
- hosts: api
  become: true
  become_user: root
  roles:
    - { role: ansible-role-puppetize, ansible_fqdn: "{{inventory_hostname_short}}.openstacklocal", ignore_puppetize_errors: true }

# Finally we run Puppet on the API servers once more. This is to make sure any
# changes created by the Puppet runs to the PuppetDB get propagated. This also
# turns fencing on on these servers.
- hosts: api
  become: true
  become_user: root
  roles:
    - { role: ansible-role-puppetize, ansible_fqdn: "{{inventory_hostname_short}}.openstacklocal", ignore_puppetize_errors: true }
# workaround - after three puppetizes /bin/openstack should be in place and insecure parameter can be injected.
  post_tasks:
    - name: workaround - use insecure in all /bin/openstack calls due to self-signed cert
      lineinfile:
        path: /bin/openstack
        insertafter: import\ sys
        line: "sys.argv.append('--insecure')"
      ignore_errors: true

# workaround - run again
- hosts: api
  become: true
  become_user: root
  roles:
    - { role: ansible-role-puppetize, ansible_fqdn: "{{inventory_hostname_short}}.openstacklocal", ignore_puppetize_errors: true }
### Previous play seems to be right timing for this workaround i.e. for the openstack binary to get populated.
### Commenting out & removing next if this is not needed as fallback.
#  post_tasks:
#    - name: workaround - use insecure in all /bin/openstack calls due to self-signed cert
#      lineinfile:
#        path: /bin/openstack
#        insertafter: import\ sys
#        line: "sys.argv.append('--insecure')"
#      ignore_errors: true

# workaround - once more, with feeling
- hosts: api
  become: true
  become_user: root
  roles:
    - { role: ansible-role-puppetize, ansible_fqdn: "{{inventory_hostname_short}}.openstacklocal", ignore_puppetize_errors: true }
  post_tasks:
    - name: workaround - assign admin role to service members
      shell: source /root/openrc.admintoken;openstack role add --project service --group service admin
      ignore_errors: true
    - shell: iptables -F

# workaround - finally, fail if there are errors
- hosts: api
  serial: 1
  become: true
  become_user: root
  roles:
    - { role: ansible-role-puppetize, ansible_fqdn: "{{inventory_hostname_short}}.openstacklocal" }
